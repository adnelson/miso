{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE LambdaCase                 #-}
-- | Tool for starting and stopping subscriptions while app is running.
module Miso.Subscription.Manager (
  SubscriptionManager,
  newSubscriptionManager,
  startSubscription,
  stopSubscription,
  managerSub
  ) where

import Prelude
import GHC.Generics (Generic)
import Control.Concurrent.MVar (MVar, newMVar, newEmptyMVar)
import Control.Concurrent.MVar (modifyMVar, modifyMVar_, readMVar, putMVar)
import Control.Concurrent.Chan (Chan, newChan, writeChan, readChan)
import Control.Monad (forever)
import Data.IORef (IORef, newIORef, readIORef, writeIORef)
import Data.IntMap (IntMap)
import qualified Data.IntMap as IM

import Miso.Html.Internal (Sub)


-- | Provides facilities for adding/removing subscriptions.
data SubscriptionManager action model = SubscriptionManager {
  -- | Managed subscriptions. What is stored here is a mutable boolean
  -- which we set to "false" when the subscription is stopped, making
  -- it skip writing generated events to the channel.
  subscriptions :: MVar (IntMap (IORef Bool), Int),
  -- | Channel for subscriptions to write their events to.
  eventsChan :: Chan action,
  -- | Some subscription types need access to the mutable model. Store here.
  ioModel :: MVar (IO model)
  } deriving (Generic)

-- | Create a new subscription manager.
newSubscriptionManager :: IO (SubscriptionManager action model)
newSubscriptionManager = SubscriptionManager <$> newMVar (mempty, 0)
                                             <*> newChan
                                             <*> newEmptyMVar

-- | Add a new subscription to the manager.
--
-- This can be called before 'managerSub' is, but it will block until then.
startSubscription
  :: SubscriptionManager action model -- ^ Manager.
  -> Sub action model -- ^ Subscription function. Non-blocking.
  -> IO Int -- ^ ID of the new subscription.
startSubscription manager sub = do
  getModel <- readMVar (ioModel manager)
  modifyMVar (subscriptions manager) $ \(subs, subId) -> do
    subIsActive <- newIORef True
    sub getModel $ \action -> readIORef subIsActive >>= \case
      True -> writeChan (eventsChan manager) action
      False -> pure ()
    pure ((IM.insert subId subIsActive subs, subId + 1), subId)

-- | Stop a subscription, given its ID.
--
-- Note that this only prevents any actions generated by that
-- subscription from entering the channel. It's the responsibility of
-- the user to stop any asynchronous functions/threads/etc that might
-- be producing those events. For example, if your subscription gets
-- events from a WebSocket, you should close that websocket so it's
-- not using CPU/memory.
--
-- Idempotent and safe to call even if the given ID doesn't exist.
stopSubscription :: SubscriptionManager action model -> Int -> IO ()
stopSubscription manager subId = do
  modifyMVar_ (subscriptions manager) $ \(subs, nextId) -> do
    case IM.lookup subId subs of
      Nothing -> pure (subs, nextId)
      Just ref -> (IM.delete subId subs, nextId) <$ writeIORef ref False

-- | Create a subscription from a subscription manager.
managerSub :: SubscriptionManager action model -> Sub action model
managerSub manager getModel sink = do
  putMVar (ioModel manager) getModel
  forever $ readChan (eventsChan manager) >>= sink
